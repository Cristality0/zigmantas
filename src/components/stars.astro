---
// inspired by https://github.com/realvjy
// Stars background effect component
// Creates an animated starfield with twinkling stars that fade in,
// change brightness, and appear/disappear over time
// Also includes shooting stars that streak across the screen
---

<canvas id="stars-canvas" aria-hidden="true"></canvas>

<style>
  #stars-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
    opacity: 0;
    animation: stars-fade-in 1s ease-out forwards;
  }

  @keyframes stars-fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
</style>

<script>
  interface Star {
    x: number;
    y: number;
    brightness: number;
    targetBrightness: number;
    fadeSpeed: number;
    twinkleSpeed: number;
    phase: number;
    lifespan: number;
    age: number;
    state: "appearing" | "alive" | "disappearing";
  }

  interface ShootingStar {
    x: number;
    y: number;
    prevX: number;
    prevY: number;
    angle: number;
    speed: number; // pixels per second
    progress: number; // 0 to 1 for interpolation
  }

  const canvasElement = document.getElementById("stars-canvas");
  if (!canvasElement) {
    throw new Error("Canvas element not found");
  }

  if (!(canvasElement instanceof HTMLCanvasElement)) {
    throw new Error("Element is not a canvas");
  }
  const canvas = canvasElement;

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Could not get canvas context");
  }

  let stars: Star[] = [];
  let shootingStar: ShootingStar | null = null;
  let animationId: number;
  let shootingStarTimeout: number;

  const STAR_COUNT = 120;
  const SHOOTING_STAR_MIN_DELAY = 4200;
  const SHOOTING_STAR_MAX_DELAY = 8700;
  const SHOOTING_STAR_TAIL_LENGTH = 60;
  const BOUNDS_BUFFER = 100;
  const INITIAL_STAGGER_MS = 500;
  const MAX_DELTA_TIME = 100;
  const STAR_SIZE = 1.5;

  function resizeCanvas(): void {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function createStar(): Star {
    return {
      x: Math.floor(Math.random() * canvas.width),
      y: Math.floor(Math.random() * canvas.height),
      brightness: 0,
      targetBrightness: 0.3 + Math.random() * 0.5,
      fadeSpeed: 0.001 + Math.random() * 0.002,
      twinkleSpeed: 0.008 + Math.random() * 0.012,
      phase: Math.random() * Math.PI * 2,
      lifespan: 10_000 + Math.random() * 15_000,
      age: 0,
      state: "appearing",
    };
  }

  function getRandomStartPoint(): { x: number; y: number; angle: number } {
    const side = Math.floor(Math.random() * 4);
    const offset = Math.random() * Math.max(canvas.width, canvas.height);

    switch (side) {
      case 0: // Top
        return { x: offset, y: 0, angle: 45 };
      case 1: // Right
        return { x: canvas.width, y: offset, angle: 135 };
      case 2: // Bottom
        return { x: offset, y: canvas.height, angle: 225 };
      case 3: // Left
        return { x: 0, y: offset, angle: 315 };
      default:
        return { x: 0, y: 0, angle: 45 };
    }
  }

  function createShootingStar(): void {
    const { x, y, angle } = getRandomStartPoint();
    shootingStar = {
      x,
      y,
      prevX: x,
      prevY: y,
      angle,
      speed: 600 + Math.random() * 400, // pixels per second (600-1000)
      progress: 0,
    };
  }

  function scheduleNextShootingStar(): void {
    const delay =
      Math.random() * (SHOOTING_STAR_MAX_DELAY - SHOOTING_STAR_MIN_DELAY) +
      SHOOTING_STAR_MIN_DELAY;
    shootingStarTimeout = window.setTimeout(() => {
      createShootingStar();
      scheduleNextShootingStar();
    }, delay);
  }

  function updateShootingStar(deltaTime: number): void {
    if (!shootingStar) {
      return;
    }

    const angleRad = (shootingStar.angle * Math.PI) / 180;

    // Store previous position for smooth interpolation
    shootingStar.prevX = shootingStar.x;
    shootingStar.prevY = shootingStar.y;

    // Delta-time based movement for consistent speed across frame rates
    const distance = shootingStar.speed * (deltaTime / 1000);
    shootingStar.x += distance * Math.cos(angleRad);
    shootingStar.y += distance * Math.sin(angleRad);

    // Check if out of bounds
    if (
      shootingStar.x < -BOUNDS_BUFFER ||
      shootingStar.x > canvas.width + BOUNDS_BUFFER ||
      shootingStar.y < -BOUNDS_BUFFER ||
      shootingStar.y > canvas.height + BOUNDS_BUFFER
    ) {
      shootingStar = null;
    }
  }

  function drawShootingStar(): void {
    if (!(shootingStar && ctx)) {
      return;
    }

    const tailLength = SHOOTING_STAR_TAIL_LENGTH;
    const angleRad = (shootingStar.angle * Math.PI) / 180;

    // Calculate tail end position
    const tailX = shootingStar.x - tailLength * Math.cos(angleRad);
    const tailY = shootingStar.y - tailLength * Math.sin(angleRad);

    // Create gradient for the shooting star trail
    const gradient = ctx.createLinearGradient(
      tailX,
      tailY,
      shootingStar.x,
      shootingStar.y
    );
    gradient.addColorStop(0, "rgba(180, 242, 255, 0)");
    gradient.addColorStop(0.5, "rgba(72, 220, 249, 0.4)");
    gradient.addColorStop(0.8, "rgba(200, 240, 255, 0.8)");
    gradient.addColorStop(1, "rgba(255, 255, 255, 1)");

    ctx.save();

    // Draw main trail with smooth anti-aliased line
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(shootingStar.x, shootingStar.y);
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 1;
    ctx.lineCap = "round";
    ctx.stroke();

    // Draw a subtle glow around the trail
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(shootingStar.x, shootingStar.y);
    ctx.strokeStyle = "rgba(72, 220, 249, 0.15)";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.stroke();

    // Draw bright head with glow
    ctx.beginPath();
    ctx.arc(shootingStar.x, shootingStar.y, 2, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(shootingStar.x, shootingStar.y, 0.5, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255, 255, 255, 1)";
    ctx.fill();

    ctx.restore();
  }

  function initStars(): void {
    stars = [];
    for (let i = 0; i < STAR_COUNT; i++) {
      const star = createStar();
      // Stagger initial appearance
      star.age = -Math.random() * INITIAL_STAGGER_MS;
      stars.push(star);
    }
  }

  function updateStar(star: Star, deltaTime: number): void {
    star.age += deltaTime;
    star.phase += star.twinkleSpeed;

    // Calculate subtle twinkle effect
    const twinkle = Math.sin(star.phase) * 0.15 + 0.85;

    switch (star.state) {
      case "appearing":
        if (star.age < 0) {
          star.brightness = 0;
        } else {
          star.brightness += star.fadeSpeed * deltaTime * 0.06;
          if (star.brightness >= star.targetBrightness) {
            star.brightness = star.targetBrightness;
            star.state = "alive";
          }
        }
        break;
      case "alive":
        star.brightness = star.targetBrightness * twinkle;
        if (star.age > star.lifespan) {
          star.state = "disappearing";
        }
        break;
      case "disappearing":
        star.brightness -= star.fadeSpeed * deltaTime * 0.02;
        if (star.brightness <= 0) {
          star.brightness = 0;
          // Respawn the star
          const newStar = createStar();
          star.x = newStar.x;
          star.y = newStar.y;
          star.targetBrightness = newStar.targetBrightness;
          star.lifespan = newStar.lifespan;
          star.age = 0;
          star.state = "appearing";
        }
        break;
      default:
        break;
    }
  }

  function drawStar(star: Star): void {
    if (star.brightness <= 0 || !ctx) {
      return;
    }

    const alpha = Math.max(0, Math.min(1, star.brightness));
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.fillRect(star.x, star.y, STAR_SIZE, STAR_SIZE);
  }

  let lastTime = 0;

  function animate(currentTime: number): void {
    const deltaTime = lastTime
      ? Math.min(currentTime - lastTime, MAX_DELTA_TIME)
      : 16;
    lastTime = currentTime;

    if (ctx) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const star of stars) {
        updateStar(star, deltaTime);
        drawStar(star);
      }

      updateShootingStar(deltaTime);
      drawShootingStar();
    }

    animationId = requestAnimationFrame(animate);
  }

  // Handle resize - reinitialize stars to fill new canvas dimensions
  let resizeTimeout: number;
  function handleResize(): void {
    clearTimeout(resizeTimeout);
    resizeTimeout = window.setTimeout(() => {
      resizeCanvas();
      initStars();
    }, 100);
  }
  window.addEventListener("resize", handleResize);

  // Handle visibility change to pause/resume animation
  function handleVisibility(): void {
    if (document.hidden) {
      cancelAnimationFrame(animationId);
      clearTimeout(shootingStarTimeout);
    } else {
      lastTime = 0;
      animationId = requestAnimationFrame(animate);
      scheduleNextShootingStar();
    }
  }
  document.addEventListener("visibilitychange", handleVisibility);

  // Cleanup for Astro View Transitions
  document.addEventListener(
    "astro:before-swap",
    () => {
      cancelAnimationFrame(animationId);
      clearTimeout(shootingStarTimeout);
      clearTimeout(resizeTimeout);
      window.removeEventListener("resize", handleResize);
      document.removeEventListener("visibilitychange", handleVisibility);
    },
    { once: true }
  );

  // Initialize
  resizeCanvas();
  initStars();
  animationId = requestAnimationFrame(animate);
  scheduleNextShootingStar();
</script>
